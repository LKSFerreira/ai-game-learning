"""
Interface para Jogar contra a IA Treinada

Este m√≥dulo permite que um humano jogue Jogo da Velha contra
os agentes treinados por Q-Learning.

Funcionalidades:
- Carregar modelos treinados
- Interface de console interativa
- Valida√ß√£o de jogadas
- Estat√≠sticas de desempenho
- Modo de dicas (ver o que a IA faria)
"""

import sys
from pathlib import Path
from typing import Optional, List, Dict
import json
from datetime import datetime

from ambiente import JogoVelha
from agente import AgenteQLearning


class JogadorHumano:
    """
    Classe que representa o jogador humano.
    
    Respons√°vel por:
    - Receber input do usu√°rio
    - Validar jogadas
    - Mostrar informa√ß√µes de ajuda
    """
    
    def __init__(self, simbolo: str, jogador: int):
        """
        Inicializa o jogador humano.
        
        Args:
            simbolo: 'X' ou 'O'
            jogador: 1 ou 2
        """
        self.simbolo = simbolo
        self.jogador = jogador
        self.vitorias = 0
        self.derrotas = 0
        self.empates = 0
    
    def escolher_acao(
        self,
        ambiente: JogoVelha,
        mostrar_dica: bool = False,
        agente_dica: Optional[AgenteQLearning] = None
    ) -> int:
        """
        Solicita uma jogada do usu√°rio.
        
        Args:
            ambiente: Estado atual do jogo
            mostrar_dica: Se deve mostrar sugest√£o da IA
            agente_dica: Agente para gerar a dica
        
        Returns:
            Posi√ß√£o escolhida (0-8)
        """
        acoes_validas = ambiente.obter_acoes_validas()
        
        # Mostra dica se solicitado
        if mostrar_dica and agente_dica:
            estado = ambiente.obter_estado()
            dica = agente_dica.escolher_acao(estado, acoes_validas, treino=False)
            print(f"üí° Dica: A IA jogaria na posi√ß√£o {dica}")
        
        while True:
            try:
                entrada = input(f"\n{self.simbolo} - Sua jogada (0-8, 'h' para ajuda, 'd' para dica): ").strip().lower()
                
                if entrada == 'h':
                    self._mostrar_ajuda()
                    continue
                
                if entrada == 'd':
                    if agente_dica:
                        estado = ambiente.obter_estado()
                        dica = agente_dica.escolher_acao(estado, acoes_validas, treino=False)
                        print(f"üí° Dica: A IA jogaria na posi√ß√£o {dica}")
                    else:
                        print("‚ö†Ô∏è  Dica n√£o dispon√≠vel (agente n√£o carregado)")
                    continue
                
                if entrada == 'q':
                    print("\nüëã Saindo do jogo...")
                    sys.exit(0)
                
                posicao = int(entrada)
                
                if posicao not in acoes_validas:
                    if posicao < 0 or posicao > 8:
                        print("‚ö†Ô∏è  Posi√ß√£o inv√°lida! Use n√∫meros de 0 a 8.")
                    else:
                        print("‚ö†Ô∏è  Essa posi√ß√£o j√° est√° ocupada!")
                    continue
                
                return posicao
                
            except ValueError:
                print("‚ö†Ô∏è  Entrada inv√°lida! Digite um n√∫mero de 0 a 8.")
            except KeyboardInterrupt:
                print("\n\nüëã Jogo interrompido pelo usu√°rio.")
                sys.exit(0)
    
    def _mostrar_ajuda(self):
        """Mostra ajuda sobre comandos dispon√≠veis."""
        print("\n" + "="*50)
        print("üìñ AJUDA")
        print("="*50)
        print("Comandos dispon√≠veis:")
        print("  0-8  : Escolher posi√ß√£o para jogar")
        print("  h    : Mostrar esta ajuda")
        print("  d    : Pedir dica da IA")
        print("  q    : Sair do jogo")
        print("\nPosi√ß√µes do tabuleiro:")
        print("  0 | 1 | 2")
        print("  ---------")
        print("  3 | 4 | 5")
        print("  ---------")
        print("  6 | 7 | 8")
        print("="*50)


class InterfaceJogo:
    """
    Interface principal do jogo humano vs IA.
    
    Gerencia:
    - Carregamento de modelos
    - Loop do jogo
    - Estat√≠sticas de partidas
    - Menu de op√ß√µes
    """
    
    def __init__(self):
        """Inicializa a interface do jogo."""
        self.ambiente = JogoVelha()
        self.agente_ia: Optional[AgenteQLearning] = None
        self.jogador_humano: Optional[JogadorHumano] = None
        self.humano_joga_como: Optional[int] = None  # 1 (X) ou 2 (O)
        
        # Estat√≠sticas da sess√£o
        self.historico_partidas: List[Dict] = []
    
    def iniciar(self):
        """Inicia a interface do jogo."""
        self._mostrar_banner()
        self._selecionar_oponente()
        self._escolher_lado()
        self._loop_principal()
    
    def _mostrar_banner(self):
        """Mostra o banner inicial."""
        print("\n" + "="*60)
        print("üéÆ JOGO DA VELHA - HUMANO vs IA")
        print("="*60)
        print("Desafie os agentes treinados por Q-Learning!")
        print("="*60 + "\n")
    
    def _selecionar_oponente(self):
        """Permite ao usu√°rio escolher qual modelo carregar."""
        print("üìÇ Selecione seu oponente:\n")
        
        pasta_modelos = Path("modelos")
        
        if not pasta_modelos.exists():
            print("‚ùå Pasta 'modelos/' n√£o encontrada!")
            print("   Execute o treinamento primeiro (treinador.py)")
            sys.exit(1)
        
        # Lista todos os modelos dispon√≠veis
        modelos = sorted(pasta_modelos.glob("*.pkl"))
        
        if not modelos:
            print("‚ùå Nenhum modelo treinado encontrado!")
            print("   Execute o treinamento primeiro (treinador.py)")
            sys.exit(1)
        
        # Agrupa modelos finais e checkpoints
        modelos_finais = [m for m in modelos if "final" in m.name]
        checkpoints = [m for m in modelos if "checkpoint" in m.name]
        
        opcoes = []
        contador = 1
        
        if modelos_finais:
            print("üèÜ Modelos Finais:")
            for modelo in modelos_finais[:5]:  # Mostra at√© 5 mais recentes
                print(f"  {contador}. {modelo.name}")
                opcoes.append(modelo)
                contador += 1
            print()
        
        if checkpoints:
            print("üíæ Checkpoints (√∫ltimos 3):")
            for modelo in checkpoints[-3:]:
                print(f"  {contador}. {modelo.name}")
                opcoes.append(modelo)
                contador += 1
            print()
        
        print(f"  {contador}. Caminho customizado")
        print("  0. Sair\n")
        
        while True:
            try:
                escolha = int(input("Digite o n√∫mero da op√ß√£o: "))
                
                if escolha == 0:
                    print("üëã At√© logo!")
                    sys.exit(0)
                
                if escolha == contador:
                    caminho = input("Digite o caminho do modelo: ").strip()
                    caminho_modelo = Path(caminho)
                else:
                    caminho_modelo = opcoes[escolha - 1]
                
                if not caminho_modelo.exists():
                    print("‚ùå Arquivo n√£o encontrado!")
                    continue
                
                print(f"\nüì• Carregando {caminho_modelo.name}...")
                self.agente_ia = AgenteQLearning.carregar(str(caminho_modelo))
                print("‚úÖ Modelo carregado com sucesso!\n")
                break
                
            except (ValueError, IndexError):
                print("‚ö†Ô∏è  Op√ß√£o inv√°lida!")
            except Exception as e:
                print(f"‚ùå Erro ao carregar modelo: {e}")
                sys.exit(1)
    
    def _escolher_lado(self):
        """Permite ao usu√°rio escolher se joga como X ou O."""
        print("üé≤ Escolha seu lado:\n")
        print("  1. Jogar como X (voc√™ come√ßa)")
        print("  2. Jogar como O (IA come√ßa)")
        print("  3. Aleat√≥rio\n")
        
        while True:
            try:
                escolha = int(input("Digite o n√∫mero da op√ß√£o: "))
                
                if escolha == 1:
                    self.humano_joga_como = 1
                    self.jogador_humano = JogadorHumano('X', 1)
                    print("\n‚úÖ Voc√™ joga como X (come√ßa primeiro)\n")
                    break
                elif escolha == 2:
                    self.humano_joga_como = 2
                    self.jogador_humano = JogadorHumano('O', 2)
                    print("\n‚úÖ Voc√™ joga como O (IA come√ßa)\n")
                    break
                elif escolha == 3:
                    import random
                    self.humano_joga_como = random.choice([1, 2])
                    simbolo = 'X' if self.humano_joga_como == 1 else 'O'
                    self.jogador_humano = JogadorHumano(simbolo, self.humano_joga_como)
                    quem_comeca = "voc√™" if self.humano_joga_como == 1 else "IA"
                    print(f"\nüé≤ Sorteio: Voc√™ joga como {simbolo} ({quem_comeca} come√ßa)\n")
                    break
                else:
                    print("‚ö†Ô∏è  Op√ß√£o inv√°lida!")
                    
            except ValueError:
                print("‚ö†Ô∏è  Digite um n√∫mero v√°lido!")
    
    def _loop_principal(self):
        """Loop principal do jogo."""
        continuar = True
        
        while continuar:
            self._jogar_partida()
            continuar = self._perguntar_continuar()
        
        self._mostrar_estatisticas_finais()
    
    def _jogar_partida(self):
        """Executa uma partida completa."""
        self.ambiente.resetar()
        
        print("\n" + "="*60)
        print("üéÆ NOVA PARTIDA")
        print("="*60)
        
        # Mostra quem come√ßa
        if self.ambiente.jogador_atual == self.humano_joga_como:
            print(f"Voc√™ ({self.jogador_humano.simbolo}) come√ßa!")
        else:
            simbolo_ia = 'X' if self.agente_ia.jogador == 1 else 'O'
            print(f"IA ({simbolo_ia}) come√ßa!")
        
        # Loop da partida
        while not self.ambiente.finalizado:
            # Mostra o tabuleiro
            print()
            self.ambiente.renderizar_com_indices()
            
            # Determina quem joga
            if self.ambiente.jogador_atual == self.humano_joga_como:
                # Turno do humano
                acao = self.jogador_humano.escolher_acao(
                    self.ambiente,
                    agente_dica=self.agente_ia
                )
            else:
                # Turno da IA
                estado = self.ambiente.obter_estado()
                acoes_validas = self.ambiente.obter_acoes_validas()
                acao = self.agente_ia.escolher_acao(estado, acoes_validas, treino=False)
                simbolo_ia = 'X' if self.agente_ia.jogador == 1 else 'O'
                print(f"\nü§ñ IA ({simbolo_ia}) jogou na posi√ß√£o {acao}")
            
            # Executa a jogada
            self.ambiente.fazer_jogada(acao)
        
        # Mostra resultado final
        print()
        self.ambiente.renderizar()
        self._mostrar_resultado()
        self._registrar_partida()
    
    def _mostrar_resultado(self):
        """Mostra o resultado da partida."""
        print("="*60)
        
        if self.ambiente.vencedor == 0:
            print("ü§ù EMPATE!")
            self.jogador_humano.empates += 1
        elif self.ambiente.vencedor == self.humano_joga_como:
            print("üéâ VOC√ä VENCEU! Parab√©ns!")
            self.jogador_humano.vitorias += 1
        else:
            print("üòî IA VENCEU! Tente novamente.")
            self.jogador_humano.derrotas += 1
        
        print("="*60)
        
        # Mostra estat√≠sticas da sess√£o
        total = self.jogador_humano.vitorias + self.jogador_humano.derrotas + self.jogador_humano.empates
        print(f"\nüìä Estat√≠sticas da Sess√£o:")
        print(f"   Vit√≥rias:  {self.jogador_humano.vitorias}/{total}")
        print(f"   Derrotas:  {self.jogador_humano.derrotas}/{total}")
        print(f"   Empates:   {self.jogador_humano.empates}/{total}")
    
    def _registrar_partida(self):
        """Registra dados da partida para estat√≠sticas."""
        resultado = None
        if self.ambiente.vencedor == 0:
            resultado = "empate"
        elif self.ambiente.vencedor == self.humano_joga_como:
            resultado = "vitoria"
        else:
            resultado = "derrota"
        
        self.historico_partidas.append({
            'timestamp': datetime.now().isoformat(),
            'humano_simbolo': self.jogador_humano.simbolo,
            'resultado': resultado,
            'vencedor': self.ambiente.vencedor
        })
    
    def _perguntar_continuar(self) -> bool:
        """Pergunta se o usu√°rio quer continuar jogando."""
        while True:
            resposta = input("\nüéÆ Jogar novamente? (s/n): ").strip().lower()
            if resposta in ['s', 'sim', 'y', 'yes']:
                return True
            elif resposta in ['n', 'n√£o', 'nao', 'no']:
                return False
            else:
                print("‚ö†Ô∏è  Responda 's' para sim ou 'n' para n√£o.")
    
    def _mostrar_estatisticas_finais(self):
        """Mostra estat√≠sticas finais da sess√£o."""
        print("\n" + "="*60)
        print("üìä ESTAT√çSTICAS FINAIS DA SESS√ÉO")
        print("="*60)
        
        total = len(self.historico_partidas)
        vitorias = self.jogador_humano.vitorias
        derrotas = self.jogador_humano.derrotas
        empates = self.jogador_humano.empates
        
        if total > 0:
            taxa_vitoria = (vitorias / total) * 100
            taxa_empate = (empates / total) * 100
            
            print(f"Partidas jogadas:  {total}")
            print(f"Vit√≥rias:          {vitorias} ({taxa_vitoria:.1f}%)")
            print(f"Derrotas:          {derrotas} ({(derrotas/total)*100:.1f}%)")
            print(f"Empates:           {empates} ({taxa_empate:.1f}%)")
            print()
            
            # An√°lise de desempenho
            if taxa_vitoria > 40:
                print("üèÜ EXCELENTE! Voc√™ est√° jogando muito bem contra a IA!")
            elif taxa_empate > 60:
                print("ü§ù √ìTIMO! Voc√™ est√° no n√≠vel da IA (muitos empates).")
            elif taxa_vitoria + taxa_empate > 50:
                print("üëç BOM! Continue praticando para melhorar ainda mais.")
            else:
                print("üí™ Continue treinando! A IA √© forte, mas voc√™ pode venc√™-la.")
            
            # Salva estat√≠sticas
            self._salvar_estatisticas()
        
        print("\nüëã Obrigado por jogar! At√© a pr√≥xima.")
    
    def _salvar_estatisticas(self):
        """Salva estat√≠sticas da sess√£o em arquivo."""
        pasta_stats = Path("estatisticas_jogador")
        pasta_stats.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        caminho = pasta_stats / f"sessao_{timestamp}.json"
        
        dados = {
            'timestamp_inicio': self.historico_partidas[0]['timestamp'],
            'timestamp_fim': self.historico_partidas[-1]['timestamp'],
            'total_partidas': len(self.historico_partidas),
            'vitorias': self.jogador_humano.vitorias,
            'derrotas': self.jogador_humano.derrotas,
            'empates': self.jogador_humano.empates,
            'modelo_ia': str(self.agente_ia.obter_estatisticas()['episodios']),
            'historico': self.historico_partidas
        }
        
        with open(caminho, 'w', encoding='utf-8') as arquivo:
            json.dump(dados, arquivo, indent=2, ensure_ascii=False)
        
        print(f"\nüíæ Estat√≠sticas salvas em '{caminho}'")


# ===== FUN√á√ÉO PRINCIPAL =====

def main():
    """Fun√ß√£o principal para executar o jogo."""
    try:
        interface = InterfaceJogo()
        interface.iniciar()
    except KeyboardInterrupt:
        print("\n\nüëã Jogo interrompido. At√© logo!")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
